<?php

	/*********************************************************************************************
	*		MetadataEventHandler reports and inserts event information generated by the
	*		EMiC Watson Project's image backup routine.
	*
	*		Acceptable input parameters:
	*				-- filename (a unique filename representing a scanned image from the archive)
	*						(can be null on a request about a bag)
	*				-- path (the current location of the image)
	*				-- action (the current state of the file: could be a format, a location, etc.)
	*						- action == 'all' returns all file statuses in reverse chron order (newest at top)
	*						- action == 'clear' deletes all records pertaining to this file
	*						- action ~= /bag/ == do the same thing but with a bag record
	*
	*		Output:
	*				-- returns the string 'true' if the input is already in the database;
	*				-- otherwise, returns 'false' and inserts the current state into the database.
	*
	*		This class uses the following classes, which are autoloaded when needed:
	*				--	DBConn (a singleton PHP class that returns a valid database connection)
	*
	*		Contact:
	*				-- Harvey Quamen <hquamen@ualberta.ca>
	*				-- Matt Bouchard <matt.bouchard@gmail.com>
	*				-- Peter Binkley <peter.binkley@ualberta.ca>
	*				-- Jeannie Sadman at dogmail.com
	*********************************************************************************************/

class MetadataEventHandler {

	protected $db;				//	a MySQLi database object returned by the static DBConn class
	protected $params;			//	array of valid parameters that match database column tables
	protected $table = 'image_metadata_event';
	
	protected $log_events = true;
	protected $default_logfile = 'logs/default_logfile.log';
	protected $log_query_string = true;	//	log the $_REQUEST params?
	
	public function __construct() {
		$this->db = DBConn::getConnection();
		$this->setParamsFromDatabase();
		date_default_timezone_set( 'America/Edmonton' );			//	for proper logging timestamps
	}
	
	/*************************************************************************************
	*	Automatic getter and setter methods
	*			(will ignore a set if a matching column does not exist in database)
	*************************************************************************************/
	public function __get( $key ) {
		return ( array_key_exists( $key, $this->params ) ) ? $this->params[ $key ] : null;
	}
	
	public function __set( $key, $value ) {
		if ( $key == 'path' ) $value = $this->normalizePath( $value );
		if ( array_key_exists( $key, $this->params ) ) $this->params[ $key ] = $value;
	}
	
	protected function setParamsFromDatabase() {
		//	This method initializes the $params array according to columns in the db table.
		$result = $this->db->query( "SHOW COLUMNS FROM {$this->table}" );
		while ( $row = $result->fetch_assoc() ) {
			$this->params[ $row['Field'] ] = null;
		}
	}
	
	public function check() {
	/*************************************************************************************
	*	check() method collects only valid parameters from HTTP $_REQUEST array
	*	and does the following:
	*			-- if ( $action == 'get' ) return current status and timestamp
	*			-- if ( $action == 'all' ) return descending list of all actions and timestamps
	*			-- if ( $action == 'clear' ) then deletes all records pertaining to this file
	*		Otherwise:
	*			-- queries the database for the existence of a matching record.
	*					-- if it exists, return 'true'
	*					-- if it does not exist, INSERT and return 'false'
	*		Finally:
	*			-- if anything else goes wrong return 'error'
	*
	*		Note:
	*			-- changed from $_GET to $_REQUEST b/c Peter Binkley is using proper
	*				GET/POST syntax in his RESTful queries.  (2013-07-03)
	*************************************************************************************/
		
		//	"smart set" -- set only if $key matches a column in the database
		foreach ( $_REQUEST as $key => $value ) $this->$key = $value;
		
		$this->log();			//	blank line to separate this request from others in the logfile
		$this->log( 'Processing request from IP ' . $_SERVER['REMOTE_ADDR'] );
		if ( $this->log_query_string ) $this->logQueryString();
		
		//	output a plain text header so that \n works
		header( 'Content-Type: text/plain' );
		
		if ( $this->checkBagIDRequest() ) return;
		if ( $this->checkWantBag() ) return;
		if ( $this->checkGetRequest() ) return;	//	typically, this is a non-op. Any harm if we drop thru?
		if ( $this->checkAllStatuses() ) return;
		if ( $this->checkRunStart() ) return;
		if ( $this->checkClearStatuses() ) return;
		
		$this->logNewStatus();
		
	}
	
	
	
	/*************************************************************************************
	*	Listed below are methods for various checks. Called in the order above.
	*************************************************************************************/
	
	protected function checkAllStatuses() {
		//	is this action == all?
		//	Return all states of this file or bag in descending chrono order
		//	(i.e., most recent state at the top of the list)
		if ( preg_match( '/all/i' , $this->params[ 'action' ] ) ) {
			$res = $this->db->query( $this->buildAllQuery() );
			$this->log( "ALL query returned {$res->num_rows} rows." );
			while ( $row = $res->fetch_assoc() ) {
				echo $row['action'] . ' ' . $row['timestamp'] . "\n";
			}
			return true;
		}
		return false;
	}
	
	
	protected function checkBagIDRequest() {
		//	is this a bag id request? If so,
		//	return the Bag ID that the current filename is part of.
		//	This might be unnecessary now, but remains just in case.
		if ( preg_match( '/bag-?id/', $this->params['action'] ) ) {
			echo $this->parseBagID( $this->params['path'] );
			return true;
		}
		return false;
	}
	
	protected function checkClearStatuses() {
		//	is this a clear?
		//	Eliminate from the database all states pertaining to this file or bag
		if ( preg_match( '/clear/i' , $this->params['action'] ) ) {
			$rows_cleared = 0;
			//	Step 1: clear actions pertaining to this filename & path
			$res = $this->db->query( $this->buildClearQuery() );
			$rows_cleared = $this->db->affected_rows;
			$this->log( "CLEARing actions on file '" . $this->params['filename'] . "'" );
			$this->log( 'Cleared ' . $this->db->affected_rows . ' rows.' );
			
			//	Step 2: if a Bag, clear all file actions inside.
			//	I believe this means simply clearing all rows having this path
			if ( preg_match( '/bag/i', $this->params['action'] ) ) {
				$res2 = $this->db->query( $this->buildClearPathQuery() );
				$this->log( "CLEARing all actions on path '" . $this->params['path'] . "'" );
				$this->log( 'Cleared ' . $this->db->affected_rows . ' rows.' );
				$rows_cleared += $this->db->affected_rows;
			}
			
			$this->log( "CLEAR query affected {$rows_cleared} total rows." );
			
			$res = $this->db->query( $this->buildInsertQuery() );
			if ( $this->db->errno != 0 ) {
				$this->log( 'Query error: MySQL Error ' . $this->db->errno . ' (' . $this->db->error . ")" );
				echo 'error';
				return true;
			}
			$this->log( 'Status inserted into database.' );
			echo 'true';
			return true;
		}
		return false;
	}
	
	protected function checkGetRequest() {
		//	is this a getter?
		//	Return current state of the file or bag listed in `filename`
		
		//	Get out now if this isn't a `get` request
		if ( ! preg_match( '/\bget/i' , $this->params[ 'action' ] ) ) return false;
		
		$status = $this->getFileStatus();	// will use `filename=xxxx` from $_REQUEST
		if ( ! empty( $status ) ) {
			echo $status;
		} else {
			echo 'false';
		}
		//	don't do any more processing on a GET request
		return true;	//	main script can stop processing
	}
	
	protected function checkRunStart() {
		//	is this a new run?
		//	if so, we get a path and an action=UAL-run-start
		if ( preg_match( '/UAL-run-start/i', $this->params['action'] ) ) {
			$res = $this->db->query( $this->buildClearPathQuery() );
			$this->log( "Starting UAL run. CLEARing all actions on path '" . $this->params['path'] . "'" );
			$rows_cleared = $this->db->affected_rows;
			$this->log( 'Cleared ' . $rows_cleared . ' rows.' );
			
			$this->log( "UAL Run start CLEAR query affected {$rows_cleared} total rows." );
			
			$res = $this->db->query( $this->buildInsertQuery() );
			if ( $this->db->errno != 0 ) {
				$this->log( 'Query error: MySQL Error ' . $this->db->errno . ' (' . $this->db->error . ")" );
				echo 'error';
				return;
			}
			$this->log( 'Status inserted into database.' );
			
			if ( $this->db->errno == 0 ) {
				echo "false";
			} else {
				echo "error";
			}
			return true;
		}
		return false;
	}
	
	protected function checkWantBag() {
		//	is this an action=want-bag? If not, get out now
		if ( ! preg_match( '/want-bag/i', $this->params[ 'action' ] ) ) return false;
	
		$this->log( "Processing WANT-BAG query." );
		
		//	Multiple scenarios:
		//	CASE 1:
		//		If we have nothing on this bag, then we want it
		
		if ( ! $this->getFileStatus() ) {
			$this->log( 'No data on this bag. We want it. Returning true.' );
			echo 'true';
			return true;	//	main script has permission to cease processing
		}
		
			//	Otherwise, set three flags before continuing:
			//		$UAL_run_end
			//		$CWRC_verifybag_end
			//		$CWRC_verifybag_false
			//		$CWRC_run_end
		
		$UAL_run_end = $this->doWeHaveAction('UAL-run-end');
		$CWRC_verifybag_end = $this->doWeHaveAction('CWRC-verifybag-end');
		$CWRC_verifybag_false = $this->doWeHaveAction('CWRC-verifybag-false');
		$CWRC_run_end = $this->doWeHaveAction('CWRC-run-end');
		
		
		//	CASE 2:
		//		If CWRC-verifybag-end is in the db; 
		//		Peter's want-bag query should get a false (CWRC has verified the bag, 
		//		it's ok, and you can ignore this bag)
		
		if ( $CWRC_run_end ) {
			$this->log( 'Bag has been verified and processed. Returning false.' );
			echo 'false';
			return true;	//	main script can cease processing
		}
		
		
		//	CASE 3:
		//		The bag history contains CWRC-verifybag-false (and, at this point, we
		//		have no CWRC-verifybag-end), so Peter's want-bag query should
		//		get a true (so he re-processes the bag).
		
		if ( $CWRC_verifybag_false ) {
			$this->log( 'CWRC cannot verify the bag. Re-process. Returning true.' );
			echo 'true';
			return true;	//	main script can cease processing
		}

		//	CASE 4:
		//		There's a UAL-uploadbag-end (or something even that didn't reach this point)
		//		AND there's no "CWRC-verifybag-end". In this case, Peter's script should get a 
		//		false--meaning no, we don't want the bag right now-- (as CWRC hasn't verified the bag)
		
		if ( $UAL_run_end and ! $CWRC_run_end ) {
			$this->log( 'CWRC has not finished processing bag. We do not want bag. Returning false.');
			echo 'false';
			return true;	//	main script can cease processing
		}
		
		//	Don't know what's happened at this point, but we can return `true` to prevent
		//	main script from logging a state.
		$this->log( 'Falling through checkWantBag(); action was "' . $this->params['action'] . '"' );
		//	We'll get here if UAL is in-process but hasn't reached 'UAL-run-end' yet;
		//	this has happened half a dozen times or so. I'm not sure what Peter's script might
		//	be doing, but let's be safe and just say we want the bag.
		echo 'true';
		return true;
	}
	
	/******************************
	*
	*	GETTERS
	*
	******************************/
	
	protected function doWeHaveAction( $action = null ) {
		if ( empty( $action ) ) return false;
		$res = $this->db->query( $this->buildQueryByAction( $action ) );
		if ( $res->num_rows > 0 ) {
			$flag = true;
		} else {
			$flag = false;
		}
		if ( $this->log_events ) {
			$this->log( 'Query returned ' . $res->num_rows . ' rows.' );
			$log = "Do we have action '{$action}' = ";
			$log .= $flag ? 'true' : 'false';
			$this->log( $log );
		}
		return $flag;
	}
	
	public function getFileStatus() {
		$res = $this->db->query( $this->buildGetQuery() );
		$this->log( "GET query returned {$res->num_rows} rows." );
		if ( $res->num_rows == 1 ) {
			$row = $res->fetch_assoc();
			return $row['action'] . ' ' . $row['timestamp'];
		}
		return null;
	}
	
	public function logNewStatus() {
		//	If we've arrived here, all special case requests have been handled,
		//	and this request is probably logging a new state.
		
		//	First, check for existence in database; if so, return 'true'
		$res = $this->db->query( $this->buildSelectQuery() );
		$this->log( "SELECT returned {$res->num_rows} rows." );
		if ( $res->num_rows == 1 ) {
			echo 'true';
			return true;
		}
		
		$res = $this->db->query( $this->buildInsertQuery() );
		if ( $this->db->errno != 0 ) {
			$this->log( 'Query error: MySQL Error ' . $this->db->errno . ' (' . $this->db->error . ")" );
			echo 'error';
			return true;
		}
		$this->log( 'Status inserted into database.' );
		echo 'false';
		return true;
	}
	
	
	
	
	/*************************************************************************************
	*	Listed below are helper methods that build queries and write to the logfile.
	*************************************************************************************/
	
	
	protected function buildAllQuery() {
		$filename = "'" . $this->db->real_escape_string( $this->params[ 'filename' ] ) . "'" ;
		$path = "'" . $this->db->real_escape_string( $this->params[ 'path' ] ) . "'" ;
		$query = "SELECT action, timestamp FROM {$this->table} WHERE filename=$filename AND path=$path 
			AND cleared='no' ORDER BY id DESC";
		$this->log( $query );
		return $query;
	}
	
	protected function buildClearQuery() {
		//	This needs to use the normalized filename so that either PB or MB can clear records
		$filename = $this->normalizeFilename( $this->params[ 'filename' ] );
		$filename = "'%" . $this->db->real_escape_string( $filename ) . "'" ;
		$path = "'" . $this->db->real_escape_string( $this->params[ 'path' ] ) . "'" ;
		$query = "UPDATE {$this->table} SET cleared='yes' WHERE normalized_filename LIKE $filename 
			AND path=$path AND cleared='no'";
		$this->log( $query );
		return $query;
	}
	
	protected function buildClearPathQuery() {
		//	this method returns a query to clear all the contents of a bag. Since we don't have
		//	a manifest of all filenames, this method simply looks at the path and clears records
		//	having that path. That's OK, because a bag == a directory on the hard drive.
		//	However, Peter should clear the path before he starts to process a bag:
		//		index.php?path={something}&action=clear-bag
		$path = "'" . $this->db->real_escape_string( $this->params[ 'path' ] ) . "'" ;
		$query = "UPDATE {$this->table} SET cleared='yes' WHERE path=$path AND cleared='no'";
		$this->log( $query );
		return $query;
	}
	
	protected function buildGetQuery() {
		//	July 2013
		//	This method does not need to parse out the bag IDs b/c we're not distinguishing them from filenames.
		//	However, a Matt B filename looks like this
		//		95-131-19-569-124.tiff
		//	whereas a Peter B filename looks like this:
		//		001-124\95-131-19-569-124
		//	Therefore, the db always inserts a normalized filename -- see `normalizeFilename()`.
		//	This `get` method takes any input but always queries the normalized filename column.
		//	7/22: Does this need a LIKE '%...' in the SQL?
		
		
		$filename = $this->normalizeFilename( $this->params['filename'] );
		$filename = "'%" . $this->db->real_escape_string( $filename ) . "'" ;
		$path = "'" . $this->db->real_escape_string( $this->params[ 'path' ] ) . "'" ;
		$query = "SELECT action, timestamp FROM {$this->table} WHERE normalized_filename LIKE $filename";
		if ( strlen( $this->path ) > 0 ) $query .= " AND path=$path";
		$query .= " AND cleared='no' ORDER BY id DESC LIMIT 1";
		$this->log( $query );
		return $query;
	}
	
	protected function buildInsertQuery() {
		$ip = "'" . $_SERVER['REMOTE_ADDR'] . "'";
		$action = "'" . $this->db->real_escape_string( $this->params[ 'action' ] ) . "'" ;
		$filename = "'" . $this->db->real_escape_string( $this->params[ 'filename' ] ) . "'" ;
		$normalized = $this->normalizeFilename( $this->params['filename'] );
		$normalized = "'" . $this->db->real_escape_string( $normalized ) . "'" ;
		$path = "'" . $this->db->real_escape_string( $this->params[ 'path' ] ) . "'" ;
		$query = "INSERT INTO {$this->table} VALUES (\N, $ip, $filename, $normalized, $path, $action, NOW(), 'no' )";
		$this->log( $query );
		return $query;
	}
	
	protected function buildSelectQuery() {
		//	July 2013: Modified to query for normalized filenames and non-deleted records
		$action = "'" . $this->db->real_escape_string( $this->params[ 'action' ] ) . "'" ;
		$filename = $this->normalizeFilename( $this->params['filename'] );
		$filename = "'" . $this->db->real_escape_string( $filename ) . "'" ;
		$path = "'" . $this->db->real_escape_string( $this->params[ 'path' ] ) . "'" ;
		$query = "SELECT * FROM {$this->table} WHERE normalized_filename=$filename AND path=$path AND action=$action 
			AND cleared='no'";
		$this->log( $query );
		return $query;
	}
	
	protected function buildQueryByAction( $action = null ) {
		$action = "'" . $action . "'";
		$filename = $this->normalizeFilename( $this->params['filename'] );
		$filename = "'" . $this->db->real_escape_string( $filename ) . "'" ;
		$path = "'" . $this->db->real_escape_string( $this->params[ 'path' ] ) . "'" ;
		$query = "SELECT * FROM {$this->table} WHERE normalized_filename=$filename 
			AND path=$path AND action=$action 
			AND cleared='no'
			ORDER BY id DESC";
		$this->log( $query );
		return $query;
	}
	
	
	
	//	deprecated
	
	protected function buildWantBagQuery() {
		$path = "'" . $this->db->real_escape_string( $this->params[ 'path' ] ) . "'" ;
		$query = "SELECT * FROM {$this->table} WHERE path={$path} AND action='UAL-uploadbag-end' AND 
			cleared='no' ORDER BY timestamp DESC";
		$this->log( $query );
		return $query;
	}

	
	
	
	/**************************************************************************************
	*
	*	logging methods
	*
	**************************************************************************************/


	public function log( $message = '' ) {
		if ( ! $this->log_events ) return;
		$logfile = $this->get_logname( $this->path );
		
		/*if ( ! is_writable( $this->logfile ) ) {
			echo "Logfile not writable.\n";
			return;
		}*/
		
		if ( ! empty( $message ) ) $message = date('c') . ' ' . $message;
		$message = str_replace( "\n", ' ', $message );
		$message = str_replace( "\t", ' ', $message );
		$message = preg_replace( '/\s{2,}/', ' ', $message );
		$message .= "\n";
		//@file_put_contents( $logfile, $message, FILE_APPEND );
		
		if ( ! file_put_contents( $logfile, $message, FILE_APPEND ) ) 
			file_put_contents( 'error.log', "Logfile '$logfile' not writable.\n", FILE_APPEND );
	}
	
	protected function logQueryString() {
		$params = array( 'filename', 'path', 'action' );
		$p = array();
		foreach ( $params as $key ) {
			$p[] = $key . '=' . $this->params[$key];
		}
		$this->log( 'Query string: ' . join( ' | ', $p ) );
	}
	
	protected function get_logname( $string = '' ) {
		if ( preg_match( '/(\d+-\d+-\d+-\d+\w?)/i', $string, $matches ) ) {
			return 'logs/' . $matches[1] . '.log';
		} else {
			return $this->default_logfile;
		}

	}
	
	
	/**************************************************************************************
	*
	*	Other handler methods
	*
	**************************************************************************************/
	
	protected function parseBagID( $string ) {
		//	Bag ID is between 'run' and 'data'
		//	run/2013/01/18/14-42-58-155/bag/data
		//	July 2013: Peter is putting bag names into
		//	the 'filename' parameter, but will leave this
		//	for now in case Matt needs to query bag info.
		
		if ( empty( $string ) ) return null;
		if ( preg_match( '/run\/(.+?)\/data/i', $string, $matches ) ) {
			return $matches[1];
		} else {
			return null;
		}
	}
	
	protected function normalizeFilename( $file ) {
		$file = trim( $file );
		if ( strlen( $file ) == 0 ) return '';
		//	replace Windows \ with Unix /
		$file = str_replace( '\\', '/', $file );
		//	append default '.tiff' to files not having an extension
		if ( strripos( $file, '.' ) === false ) $file .= '.tiff';
		return $file;
	}
	
	protected function normalizePath( $path ) {
		if ( strlen( $path ) == 0 ) return '';
		//	replace Windows \ with Unix /
		return str_replace( '\\', '/', $path );
	}
	
}


?>